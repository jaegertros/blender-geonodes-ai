"""
Blender Geometry Nodes Connection Compatibility Matrix
=======================================================
Discovers which socket types can connect to which, including
implicit type conversions.

Uses Group Input/Output interface sockets for clean type-to-type
testing, avoiding node-specific socket quirks.

Requires: node_catalog.json from discover_nodes.py

Usage:
    blender --background --factory-startup --python discovery/test_connections.py

Output:
    discovery/connection_matrix.json
"""

import bpy
import json
import sys
import os
from datetime import datetime


def load_node_catalog(script_dir):
    """Load the node catalog generated by discover_nodes.py."""
    catalog_path = os.path.join(script_dir, "node_catalog.json")
    if not os.path.exists(catalog_path):
        print(f"ERROR: node_catalog.json not found at {catalog_path}")
        print("Run discover_nodes.py first.")
        sys.exit(1)

    with open(catalog_path, "r", encoding="utf-8") as f:
        return json.load(f)


# Maps our discovered socket type names to the bpy interface socket types
# used by node_tree.interface.new_socket()
SOCKET_TYPE_MAP = {
    "GEOMETRY":   "NodeSocketGeometry",
    "VALUE":      "NodeSocketFloat",
    "INT":        "NodeSocketInt",
    "BOOLEAN":    "NodeSocketBool",
    "VECTOR":     "NodeSocketVector",
    "RGBA":       "NodeSocketColor",
    "STRING":     "NodeSocketString",
    "ROTATION":   "NodeSocketRotation",
    "MATRIX":     "NodeSocketMatrix",
    "OBJECT":     "NodeSocketObject",
    "COLLECTION": "NodeSocketCollection",
    "IMAGE":      "NodeSocketImage",
    "MATERIAL":   "NodeSocketMaterial",
    "MENU":       "NodeSocketMenu",
}

# Types we skip because they can't be created as interface sockets
SKIP_TYPES = {"CUSTOM", "BUNDLE", "CLOSURE"}


def test_connection_via_interface(source_type, target_type):
    """
    Test whether source_type output can connect to target_type input
    using Group Input/Output interface sockets.

    Creates a fresh node tree with one output socket of source_type
    and one input socket of target_type, then tries to link them.
    """
    tree_name = f"__test_{source_type}_to_{target_type}__"
    tree = bpy.data.node_groups.new(tree_name, "GeometryNodeTree")

    result = {
        "valid": False,
        "error": None,
        "link_created": False,
        "conversion_nodes_added": 0,
    }

    try:
        source_bpy_type = SOCKET_TYPE_MAP.get(source_type)
        target_bpy_type = SOCKET_TYPE_MAP.get(target_type)

        if not source_bpy_type or not target_bpy_type:
            result["error"] = f"No bpy socket type mapping for {source_type} or {target_type}"
            return result

        # Create interface sockets: an input (appears as output on Group Input node)
        # and an output (appears as input on Group Output node)
        tree.interface.new_socket(
            name="TestSource", in_out="INPUT", socket_type=source_bpy_type
        )
        tree.interface.new_socket(
            name="TestTarget", in_out="OUTPUT", socket_type=target_bpy_type
        )

        # Find Group Input and Group Output nodes (auto-created with interface sockets)
        group_input = None
        group_output = None
        for node in tree.nodes:
            if node.type == "GROUP_INPUT":
                group_input = node
            elif node.type == "GROUP_OUTPUT":
                group_output = node

        if not group_input or not group_output:
            # Create them manually if needed
            if not group_input:
                group_input = tree.nodes.new("NodeGroupInput")
            if not group_output:
                group_output = tree.nodes.new("NodeGroupOutput")

        # Find the right sockets by name
        source_socket = None
        for s in group_input.outputs:
            if s.name == "TestSource":
                source_socket = s
                break

        target_socket = None
        for s in group_output.inputs:
            if s.name == "TestTarget":
                target_socket = s
                break

        if not source_socket:
            result["error"] = f"Could not find TestSource output on Group Input (outputs: {[s.name for s in group_input.outputs]})"
            return result
        if not target_socket:
            result["error"] = f"Could not find TestTarget input on Group Output (inputs: {[s.name for s in group_output.inputs]})"
            return result

        # Count nodes before link
        node_count_before = len(tree.nodes)

        # Attempt the connection
        link = tree.links.new(source_socket, target_socket)

        if link and link.is_valid:
            result["valid"] = True
            result["link_created"] = True
        elif link:
            result["valid"] = False
            result["link_created"] = True
            result["error"] = "Link created but marked invalid"
        else:
            result["valid"] = False
            result["error"] = "Link creation returned None"

        # Check for auto-inserted conversion nodes
        node_count_after = len(tree.nodes)
        result["conversion_nodes_added"] = node_count_after - node_count_before

    except Exception as e:
        result["error"] = str(e)
    finally:
        # Clean up
        bpy.data.node_groups.remove(tree)

    return result


def main():
    print("=" * 60)
    print("Blender Geometry Nodes Connection Matrix Discovery")
    print("=" * 60)
    print(f"Blender version: {bpy.app.version_string}")
    print()

    script_dir = os.path.dirname(os.path.abspath(__file__))
    catalog = load_node_catalog(script_dir)

    print(f"Loaded catalog with {catalog['total_nodes_cataloged']} nodes")

    all_socket_types = catalog["socket_types_found"]
    testable_types = [t for t in all_socket_types if t not in SKIP_TYPES]
    skipped_types = [t for t in all_socket_types if t in SKIP_TYPES]

    print(f"All socket types: {all_socket_types}")
    print(f"Testable types: {testable_types}")
    print(f"Skipped types (no interface socket): {skipped_types}")
    print()

    matrix = {
        "blender_version": bpy.app.version_string,
        "discovery_date": datetime.now().isoformat(),
        "method": "Group Input/Output interface sockets (clean type-to-type test)",
        "socket_type_mapping": SOCKET_TYPE_MAP,
        "testable_types": testable_types,
        "skipped_types": skipped_types,
        "connections": {},
        "summary": {
            "total_tested": 0,
            "total_valid": 0,
            "total_invalid": 0,
            "total_with_conversion": 0,
        },
    }

    total_tests = len(testable_types) * len(testable_types)
    test_num = 0

    for out_type in testable_types:
        for in_type in testable_types:
            test_num += 1
            conn_key = f"{out_type} -> {in_type}"

            progress = f"[{test_num}/{total_tests}]"
            print(f"{progress} Testing {conn_key}...", end=" ")

            result = test_connection_via_interface(out_type, in_type)
            result["source_type"] = out_type
            result["target_type"] = in_type

            matrix["connections"][conn_key] = result
            matrix["summary"]["total_tested"] += 1

            if result["valid"]:
                matrix["summary"]["total_valid"] += 1
                if result["conversion_nodes_added"] > 0:
                    matrix["summary"]["total_with_conversion"] += 1
                    print(f"VALID (with {result['conversion_nodes_added']} conversion node(s))")
                else:
                    print("VALID")
            else:
                matrix["summary"]["total_invalid"] += 1
                err = result.get("error", "")
                print(f"INVALID{' - ' + err if err else ''}")

    # Build quick-reference compatibility table
    compat_table = {}
    for out_type in testable_types:
        compat_table[out_type] = {}
        for in_type in testable_types:
            conn_key = f"{out_type} -> {in_type}"
            conn = matrix["connections"].get(conn_key, {})
            if conn.get("valid"):
                if conn.get("conversion_nodes_added", 0) > 0:
                    compat_table[out_type][in_type] = "CONVERT"
                else:
                    compat_table[out_type][in_type] = "DIRECT"
            else:
                compat_table[out_type][in_type] = "INVALID"

    matrix["quick_reference"] = compat_table

    # Print the compatibility matrix as a readable table
    print()
    print("Quick Reference Matrix:")
    print("(D=Direct, C=Convert, .=Invalid)")
    print()

    # Header
    short_names = {t: t[:5] for t in testable_types}
    header = "FROM\\TO     " + " ".join(f"{short_names[t]:>5}" for t in testable_types)
    print(header)
    print("-" * len(header))

    for out_type in testable_types:
        row = f"{out_type:<11}"
        for in_type in testable_types:
            val = compat_table[out_type].get(in_type, "?")
            if val == "DIRECT":
                cell = "D"
            elif val == "CONVERT":
                cell = "C"
            else:
                cell = "."
            row += f"{cell:>6}"
        print(row)

    # Write output
    output_path = os.path.join(script_dir, "connection_matrix.json")
    with open(output_path, "w", encoding="utf-8") as f:
        json.dump(matrix, f, indent=2, ensure_ascii=False, default=str)

    print()
    print("=" * 60)
    print("Connection matrix discovery complete!")
    print(f"  Total tested: {matrix['summary']['total_tested']}")
    print(f"  Valid (direct): {matrix['summary']['total_valid'] - matrix['summary']['total_with_conversion']}")
    print(f"  Valid (with conversion): {matrix['summary']['total_with_conversion']}")
    print(f"  Invalid: {matrix['summary']['total_invalid']}")
    print(f"  Output: {output_path}")
    print("=" * 60)


if __name__ == "__main__":
    main()
